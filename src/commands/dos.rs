use std::{
    fs,
    path::PathBuf,
    collections::HashMap,
};

use structopt::{
    StructOpt,
    clap::AppSettings,
};
use log::info;
use serde::{
    Serialize,
    Deserialize,
};
use anyhow::{
    //anyhow,
    Context,
    //Error,
    bail,
};
use toml;
use plotly;
use ndarray::{
    self,
    s,
};

use crate::{
    Result,
    OptProcess,
    Procar,
    //Outcar,
    vasp_parsers::outcar::GetEFermi,
    types::Vector,
    commands::common::{
        RawSelection,
        write_array_to_txt,
    }
};


const PI: f64 = std::f64::consts::PI;


#[derive(Clone, Debug)]
struct Selection {
    label:      String,
    ispins:     Vec<usize>,
    ikpoints:   Vec<usize>,
    iatoms:     Vec<usize>,
    iorbits:    Vec<usize>,
    factor:     f64,
}


fn rawsel_to_sel(r: HashMap<String, RawSelection>, 
                 nlm: &[String], 
                 nions: usize, 
                 nkpoints: usize,
                 nspin: usize,
                 is_ncl: bool) -> Result<Vec<Selection>> {

    let mut sel_vec = vec![];

    for (label, val) in r.into_iter() {
        let ispins      = if is_ncl {
            RawSelection::parse_ispins(   val.spins.as_deref(),   nspin,  is_ncl)?
        } else {
            RawSelection::parse_ispins(                   None,   nspin,  is_ncl)?
        };
        let ikpoints    = RawSelection::parse_ikpoints( val.kpoints.as_deref(), nkpoints)?;
        let iatoms      = RawSelection::parse_iatoms(   val.atoms.as_deref(),   nions)?;
        let iorbits     = RawSelection::parse_iorbits(  val.orbits.as_deref(),  nlm)?;
        let factor      = val.factor.unwrap_or(1.0);

        let sel = Selection {
            label: label.to_string(),
            ispins,
            ikpoints,
            iatoms,
            iorbits,
            factor,
        };

        sel_vec.push(sel);
    }

    Ok(sel_vec)
}


#[derive(Clone, Copy, Serialize, Deserialize)]
pub enum SmearingMethod {
    Gaussian,
    Lorentz,
}


#[derive(Clone, Serialize, Deserialize)]
struct Configuration {
    #[serde(default = "Configuration::method_default")]
    method: SmearingMethod,

    #[serde(default = "Configuration::sigma_default")]
    sigma: f64,

    #[serde(default = "Configuration::procar_default")]
    procar: PathBuf,

    #[serde(default = "Configuration::outcar_default")]
    outcar: PathBuf,

    #[serde(default = "Configuration::txtout_default")]
    txtout: PathBuf,

    #[serde(default = "Configuration::htmlout_default")]
    htmlout: PathBuf,

    #[serde(default = "Configuration::notot_default")]
    notot: bool,

    pdos: Option<HashMap<String, RawSelection>>,
}

impl Configuration {
    pub fn method_default() -> SmearingMethod { SmearingMethod::Gaussian }
    pub fn sigma_default() -> f64 { 0.05 }
    pub fn procar_default() -> PathBuf { PathBuf::from("./PROCAR") }
    pub fn outcar_default() -> PathBuf { PathBuf::from("./OUTCAR") }
    pub fn txtout_default() -> PathBuf { PathBuf::from("./dos_raw.txt") }
    pub fn htmlout_default() -> PathBuf { PathBuf::from("./dos.html") }
    pub fn notot_default()  -> bool { false }
}



#[derive(Debug, StructOpt, Clone)]
#[structopt(setting = AppSettings::ColoredHelp,
            setting = AppSettings::ColorAuto)]
/// Calculate density of states from PROCAR and OUTCAR.
///
/// The fermi level is extracted from OUTCAR, and DOS is calculated by
/// smearing the band levels from PROCAR. The result may differ from DOSCAR.
pub struct Dos {
    #[structopt(short, long)]
    /// Projected DOS configuration file path.
    ///
    /// If left empty, only total DOS is calculated. The configuration template
    /// can be generated by `--gen-template` and then you can follow it.
    config: Option<PathBuf>,

    #[structopt(long)]
    /// Generate projected DOS configuration template.
    gen_template: bool,

    #[structopt(long, default_value = "./OUTCAR")]
    /// OUTCAR path
    outcar: PathBuf,

    #[structopt(long, default_value = "./PROCAR")]
    /// PROCAR path
    procar: PathBuf,

    #[structopt(long, default_value = "dos_raw.txt")]
    /// Save the raw data of projected DOS. Then you can replot it with more advanced tools.
    txtout: PathBuf,

    #[structopt(long, default_value = "dos.html")]
    /// Save the projected DOS plot as HTML. Then you can view it in the browser.
    ///
    /// Note: Your browser should be able to run plotly.js. Chrome, Safari, Edge, Firefox and
    /// etc. are supported.
    htmlout: PathBuf,

    #[structopt(long)]
    /// Print brief info of PROCAR, this may be helpful when you write the configuration.
    show_brief: bool
}


// gaussian_smearing(x::AbstractArray, μ::Float64, σ=0.05) = @. exp(-(x-μ)^2 / (2*σ^2)) / (σ*sqrt(2π))
fn smearing_gaussian(x: &[f64], mus: &[f64], sigma: f64) -> Vector<f64> {
    let len = x.len();
    let inv_two_sgm_sqr = 1.0 / (2.0 * sigma.powi(2));  // 1.0/(2*σ^2)
    let inv_sgm_sqrt2pi = 1.0 / (sigma * (2.0 * PI).sqrt()); // 1.0/(σ*sqrt(2π))

    let mut ret = Vector::<f64>::zeros(len);

    for i in 0..len {
        ret[i] += mus.as_ref().iter()
            .map(|c| (-(x[i]-c).powi(2) * inv_two_sgm_sqr).exp() * inv_sgm_sqrt2pi)
            .sum::<f64>();
    }

    ret
}

// lorentz_smearing(x::AbstractArray, x0::Float64, Γ=0.05) = @. Γ/(2π) / ((x-x0)^2 + (Γ/2)^2)
fn smearing_lorentz(x: &[f64], x0s: &[f64], gamma: f64) -> Vector<f64> {
    let len = x.len();
    let gam_div_2pi = gamma / (2.0 * PI);  // Γ/(2π)
    let gam_half_sqr = (gamma / 2.0).powi(2); // (Γ/2)^2

    let mut ret = Vector::<f64>::zeros(len);

    for i in 0..len {
        ret[i] += x0s.as_ref().iter()
            .map(|c| gam_div_2pi / ((x[i] - c).powi(2) + gam_half_sqr))
            .sum::<f64>();
    }

    ret
}

fn apply_smearing(x: &[f64], centers: &[f64], width: f64, method: SmearingMethod) -> Vector<f64> {
    match method {
        SmearingMethod::Lorentz  => smearing_lorentz(x, centers, width),
        SmearingMethod::Gaussian => smearing_gaussian(x, centers, width),
    }
}


fn gen_totdos(xvals: &[f64], procar: &Procar, sigma: f64, method: SmearingMethod) -> Vector<f64> {
    let nspin       = procar.pdos.nspin as usize;
    let nkpoints    = procar.pdos.nkpoints as usize;
    let mut totdos  = vec![];
    
    let weights = &procar.kpoints.weights;
    let norm = weights.sum();

    for ispin in 0 .. nspin {
        let mut tdos = Vector::<f64>::zeros(xvals.len());
        for ikpoint in 0 .. nkpoints {
            let eigs = procar.pdos.eigvals.slice(s![ispin, ikpoint, ..]).to_slice().unwrap();
            if 0 == ispin {
                tdos += &(apply_smearing(xvals, eigs, sigma, method) * weights[ikpoint]);
            } else {
                tdos -= &(apply_smearing(xvals, eigs, sigma, method) * weights[ikpoint]);
            }
        }
        tdos /= norm;

        let tdos = if 0 == ispin {
            tdos.into_raw_vec()
        } else {
            let mut r = tdos.into_raw_vec();
            r.reverse();
            r
        };

        totdos.push(tdos);
    }

    totdos.into_iter()
        .map(|x| x.into_iter())
        .flatten()
        .collect::<_>()
}


const TEMPLATE: &'static str = r#"# rsgrad DOS configuration in toml format.
# If you want some options to be default, just comment the whole lines.
method      = "Gaussian"        # smearing method
sigma       = 0.05              # smearing width, (eV)
procar      = "PROCAR"          # PROCAR path
outcar      = "OUTCAR"          # OUTCAR path
txtout      = "dos_raw.txt"     # save the raw data as "dos_raw.txt"
htmlout     = "dos.html"        # save the pdos plot as "dos.html"
notot       = false             # plot the total dos

[pdos.plot1]     # One label produces one plot, the labels CANNOT be repetitive.
# spins   = "x y"           # for LSORBIT = .TRUE. system only, "x" "y" "z" and "tot" are available.
kpoints = "1 3..7 -1"       # selects 1 3 4 5 6 7 and the last kpoint for pdos plot, starts from 1.
atoms   = "1 3..7 -1"       # selects 1 3 4 5 6 7 and the last atoms' projection for pdos plot, starts from 1.
orbits  = "s px dxy"        # selects the s px and dx orbits' projection for pdos plot.
factor  = 1.01              # the factor multiplied to this pdos

# The fields can be left blank, if you want select all the components for some fields,
# just comment them. You can comment fields with '#'
"#;


impl OptProcess for Dos {
    fn process(&self) -> Result<()> {
        if self.gen_template {
            let conf_filename = PathBuf::from("./dos.toml");

            info!("Generating selection dos configuration template ...");
            fs::write(&conf_filename, TEMPLATE.as_bytes())?;
            info!("Template file written to {:?}. Exiting", &conf_filename);
            
            return Ok(());
        }

        let config = if let Some(config) = self.config.as_ref() {
            info!("Reading PDOS configuration from {:?}", self.config.as_ref());
            let config = fs::read_to_string(config)?;
            let config: Configuration = toml::from_str(&config)?;
            Some(config)
        } else {
            None
        };

        let procar  = if let Some(cfg) = config.as_ref() {  &cfg.procar } else {  &self.procar };
        let outcar  = if let Some(cfg) = config.as_ref() {  &cfg.outcar } else {  &self.outcar };
        let txtout  = if let Some(cfg) = config.as_ref() {  &cfg.txtout } else {  &self.txtout };
        let htmlout = if let Some(cfg) = config.as_ref() { &cfg.htmlout } else { &self.htmlout };
        let sigma   = if let Some(cfg) = config.as_ref() {    cfg.sigma } else {          0.05 };
        let method  = if let Some(cfg) = config.as_ref() {   cfg.method } else { SmearingMethod::Gaussian };
        let notot   = if let Some(cfg) = config.as_ref() {    cfg.notot } else {         false };

        info!("Parsing PROCAR file {:?}", procar);
        let mut procar  = Procar::from_file(procar)?;
        let nlm     = procar.pdos.nlm.clone();
        let nkpts   = procar.kpoints.nkpoints as usize;
        let nions   = procar.pdos.nions as usize;
        let is_ncl  = procar.pdos.lsorbit;
        let nspin   = procar.pdos.nspin as usize;
        let nbands  = procar.pdos.nbands as usize;

        if self.show_brief {
            info!("Brief info of current PROCAR:
  orbitals = {:?}
  NKPTS  = {}
  NIONS  = {}
  IS_NCL = {}
  NSPIN  = {}
  NBANDS = {}", &nlm, nkpts, nions, is_ncl, nspin, nbands);
            return Ok(());
        }

        info!("Parsing OUTCAR file {:?} for Fermi level", outcar);
        let efermi = fs::read_to_string(outcar)?.get_efermi()?;
        info!("Found Fermi level = {}, eigenvalues will be shifted.", efermi);

        procar.pdos.eigvals -= efermi;

        let emin = procar.pdos.eigvals
            .iter()
            .cloned()
            .reduce(f64::min)
            .unwrap();
        let emax = procar.pdos.eigvals
            .iter()
            .cloned()
            .reduce(f64::max)
            .unwrap();


        let mut plot = plotly::Plot::new();

        let nedos = (emax - emin).ceil() as usize * 400;  // 400 points per eV
        let xvals = Vector::<f64>::linspace(emin-2.0, emax+2.0, nedos);
        let xvals_plot = if nspin == 1 {
            xvals.clone()
        } else {
            xvals.clone()
                .into_iter()
                .chain(xvals.clone().into_raw_vec().into_iter().rev())
                .collect::<Vector<f64>>()
        };

        let totdos = gen_totdos(xvals.as_slice().unwrap(), &procar, sigma, method);

        if !notot {
            let tr = plotly::Scatter::from_array(xvals_plot.clone(), totdos.clone())
                .mode(plotly::common::Mode::Lines)
                .marker(plotly::common::Marker::new()
                        .color(plotly::NamedColor::Grey))
                .fill(plotly::common::Fill::ToZeroY)
                .name("Total DOS");
            plot.add_trace(tr);
        };

        plot.use_local_plotly();
        let layout = plotly::Layout::new()
            .title(plotly::common::Title::new("Density of States"))
            .y_axis(plotly::layout::Axis::new()
                    .title(plotly::common::Title::new("DOS (arb. unit)"))
                    .zero_line(true)
                    .fixed_range(false)
                    )
            .x_axis(plotly::layout::Axis::new()
                    .title(plotly::common::Title::new("E-Ef (eV)"))
                    .range(vec![-1.0, 6.0])
                    .zero_line(true)
                    .range_slider(plotly::layout::RangeSlider::new().visible(true))
                    );
        plot.set_layout(layout);

        info!("Writing DOS plot to {:?}", htmlout);
        plot.to_html(&htmlout);

        info!("Writing raw DOS data to {:?}", txtout);
        write_array_to_txt(txtout, vec![&xvals_plot, &totdos], "E-Ef TOTDOS")?;

        Ok(())
    }
}



#[cfg(test)]
mod test {
    use super::*;

    const TEST_TEMPLATE: &'static str = r#"# rsgrad DOS configuration in toml format.
# multiple tokens inside string are seperated by whitespace
method      = "Gaussian"        # smearing method
sigma       = 0.05              # smearing width, (eV)
procar      = "PROCAR"          # PROCAR path
outcar      = "OUTCAR"          # OUTCAR path
txtout      = "dos_raw.txt"     # save the raw data as "dos_raw.txt"
htmlout     = "dos.html"        # save the pdos plot as "dos.html"
notot       = false             # plot the total dos

[pdos.plot1]                  # One label produces one plot, the labels CANNOT be repetitive.
                              # each the label is 'plot1', to add more pdos, write '[pdos.plot2]' and so on.
#spins   = "x y z"             # for LSORBIT = .TRUE. system only, "x" "y" "z" and "tot" are available.
kpoints = "1 3..7 -1"         # selects 1 3 4 5 6 7 and the last kpoint for pdos plot.
atoms   = "1 3..7 -1"         # selects 1 3 4 5 6 7 and the last atoms' projection for pdos plot.
orbits  = "s px dxy"          # selects the s px and dx orbits' projection for pdos plot.
factor  = 1.01                # the factor multiplied to this pdos

# The fields can be left blank, if you want select all the components for some fields,
# just comment them. You can comment fields with '#'
"#;
    
    #[test]
    fn test_parse_rawconfig() {
        let nlm = "s     py     pz     px    dxy    dyz    dz2    dxz    dx2" 
            .split_whitespace()
            .map(String::from)
            .collect::<Vec<_>>();
        let nions = 8usize;
        let nkpoints = 18usize;
        let nspin = 2;
        let is_ncl = false;

        let c: Configuration = toml::from_str(TEST_TEMPLATE).unwrap();
        let v = rawsel_to_sel(c.clone().pdos.unwrap(),
                              &nlm,
                              nions,
                              nkpoints,
                              nspin,
                              is_ncl).unwrap();
        assert_eq!(v[0].label, "plot1");
        assert_eq!(v[0].ispins, &[0, 1]);
        assert_eq!(v[0].iatoms, &[0, 2, 3, 4, 5, 6, 7]);
        assert_eq!(v[0].ikpoints, &[0, 2, 3, 4, 5, 6, 17]);
        assert_eq!(v[0].iorbits, &[0, 3, 4]);
        assert_eq!(v[0].factor, 1.01);

        let s = toml::to_string(&c).unwrap();
        println!("{}", s);
        println!("{:?}", v);
    }

}
