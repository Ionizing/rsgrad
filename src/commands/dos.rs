use std::{
    fs,
    path::PathBuf
};

use structopt::{
    StructOpt,
    clap::AppSettings,
};
use log::{
    info,
};
use serde::{
    Serialize,
    Deserialize,
};
use config::Config;
use anyhow::{
    Error,
    bail,
};
use toml;

use crate::{
    Result,
    OptProcess,
    Procar,
    Outcar,
    vasp_parsers::outcar::GetEFermi,
};


#[derive(Clone, Serialize, Deserialize)]
struct RawSelection {
    spins:      Option<String>,
    kpoints:    Option<String>,
    atoms:      Option<String>,
    orbits:     Option<String>,
    label:      String,
}


impl Default for RawSelection {
    fn default() -> Self {
        Self {
            spins:      Some("input spin here, can be commented".to_string()),
            kpoints:    Some("input kpoints here, can be commented".to_string()),
            atoms:      Some("input atoms here, can be commented".to_string()),
            orbits:     Some("input orbits here, can be commented".to_string()),
            label:      "You must set label".to_string()
        }
    }
}



#[derive(Clone, Serialize, Deserialize)]
struct RawSelectionVec {
    #[serde(rename = "PDOS")]
    inner: Vec<RawSelection>
}


#[derive(Clone)]
struct Selection {
    ispins:     Vec<i32>,
    ikpoints:   Vec<i32>,
    iatoms:     Vec<i32>,
    iorbits:    Vec<i32>,
    label:      String,
}


#[derive(Debug, StructOpt, Clone)]
#[structopt(setting = AppSettings::ColoredHelp,
            setting = AppSettings::ColorAuto)]
/// Calculate density of states from PROCAR and OUTCAR.
///
/// The fermi level is extracted from OUTCAR, and DOS is calculated by
/// smearing the band levels from PROCAR. The result may differ from DOSCAR.
pub struct Dos {
    #[structopt(short, long)]
    /// Projected DOS configuration file path.
    ///
    /// If left empty, only total DOS is calculated. The configuration template
    /// can be generated by `--gen-template` and then you can follow it.
    config: Option<PathBuf>,

    #[structopt(long)]
    /// Generate projected DOS configuration template.
    gen_template: bool,

    #[structopt(long, default_value = "./OUTCAR")]
    /// OUTCAR path
    outcar: PathBuf,

    #[structopt(long, default_value = "./PROCAR")]
    /// PROCAR path
    procar: PathBuf,

    #[structopt(long, default_value = "dos_raw.txt")]
    /// Save the raw data of projected DOS. Then you can replot it with more advanced tools.
    txtout: PathBuf,

    #[structopt(long, default_value = "dos.html")]
    /// Save the projected DOS plot as HTML. Then you can view it in the browser.
    ///
    /// Note: Your browser should be able to run plotly.js. Chrome, Safari, Edge, Firefox and
    /// etc. are supported.
    htmlout: PathBuf,
}


impl OptProcess for Dos {
    fn process(&self) -> Result<()> {
        if self.gen_template {
            let conf_filename = PathBuf::from("./dos.toml");

            info!("Generating selection dos configuration template ...");
            let conf = RawSelectionVec{
                inner: vec![RawSelection::default()]
            };
            let s = toml::to_string(&conf)?;
            fs::write(&conf_filename, s.as_bytes())?;
            info!("Template file written to {:?}. Exiting", &conf_filename);
            
            return Ok(());
        }

        Ok(())
    }
}
