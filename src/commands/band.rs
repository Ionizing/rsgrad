use std::{
    fs,
    path::PathBuf,
};

use indexmap::IndexMap;
use structopt::{
    StructOpt,
    clap::AppSettings,
};
use log::{
    info,
    warn,
    debug,
};
use rayon;
use anyhow::{
    bail,
    anyhow,
    Context,
};
use serde::{
    Serialize,
    Deserialize,
};

use crate::{
    Result,
    OptProcess,
    Procar,
    Outcar,
    Poscar,
    vasp_parsers::outcar::GetEFermi,
    types::{
        Mat33,
        MatX3,
        Vector,
    },
    commands::common::{
        write_array_to_txt,
        RawSelection,
    }
};


#[derive(Clone, Debug)]
struct Selection {
    label:      String,
    ispins:     Vec<usize>,
    ikpoints:   Vec<usize>,
    iatoms:     Vec<usize>,
    iorbits:    Vec<usize>,
    factor:     f64,
}


fn rawsel_to_sel(r: IndexMap<String, RawSelection>, 
                 nspin: usize,
                 is_ncl: bool,
                 nlm: &[String], 
                 nions: usize, 
                 nkpoints: usize) -> Result<Vec<Selection>> {

    let mut sel_vec = vec![];

    for (label, val) in r.into_iter() {
        let ispins      = RawSelection::parse_ispins(   val.spins.as_deref(),   nspin, is_ncl)?;
        let ikpoints    = RawSelection::parse_ikpoints( val.kpoints.as_deref(), nkpoints)?;
        let iatoms      = RawSelection::parse_iatoms(   val.atoms.as_deref(),   nions)?;
        let iorbits     = RawSelection::parse_iorbits(  val.orbits.as_deref(),  nlm)?;
        let factor      = val.factor.unwrap_or(1.0);

        if factor < 0.0 { bail!("The factor cannot be negative."); }

        let sel = Selection {
            label: label.to_string(),
            ispins,
            ikpoints,
            iatoms,
            iorbits,
            factor,
        };

        sel_vec.push(sel);
    }

    Ok(sel_vec)
}


#[derive(Clone, Serialize, Deserialize, Debug)]
struct Configuration {
    kpoint_labels: Option<Vec<String>>,

    #[serde(default = "Configuration::procar_default")]
    procar: PathBuf,

    #[serde(default = "Configuration::outcar_default")]
    outcar: PathBuf,

    #[serde(default = "Configuration::txtout_default")]
    txtout: PathBuf,

    #[serde(default = "Configuration::htmlout_default")]
    htmlout: PathBuf,

    #[serde(default = "Configuration::is_hse_default")]
    is_hse: bool,

    pband: Option<IndexMap<String, RawSelection>>,
}

impl Configuration {
    pub fn procar_default() -> PathBuf { PathBuf::from("./PROCAR") }
    pub fn outcar_default() -> PathBuf { PathBuf::from("./OUTCAR") }
    pub fn txtout_default() -> PathBuf { PathBuf::from("./band_raw.txt") }
    pub fn htmlout_default() -> PathBuf { PathBuf::from("./band.html") }
    pub fn is_hse_default() -> bool { false }
}


#[derive(Debug, StructOpt, Clone)]
#[structopt(setting = AppSettings::ColoredHelp,
            setting = AppSettings::ColorAuto)]
pub struct Band {
    #[structopt(short, long)]
    /// Band structure plot configuration file path.
    ///
    /// If left empty, only bare band is calculated. The configuration template
    /// can be generated by `--gen-template` and then you can follow it.
    config: Option<PathBuf>,

    #[structopt(long)]
    /// Generate band structure plot configuration template.
    gen_template: bool,

    #[structopt(short, long)]
    /// Symbols for high symmetry points on the kpoint path.
    kpoint_labels: Option<Vec<String>>,

    #[structopt(long)]
    /// Specify the system is calculated via HSE method or not.
    is_hse: bool,

    #[structopt(long, default_value = "./PROCAR")]
    /// PROCAR path.
    ///
    /// The band level and projected band info are extracted from PROCAR.
    procar: PathBuf,

    #[structopt(long, default_value = "./OUTCAR")]
    /// OUTCAR path.
    ///
    /// The fermi level and lattice info are extracted from OUTCAR.
    outcar: PathBuf,

    #[structopt(long, default_value = "band.txt")]
    /// Save the raw data of band structure.
    ///
    /// Then you can replot it with more advanced tools.
    txtout: PathBuf,

    #[structopt(long, default_value = "band.html")]
    /// Save the band structure plot as HTML.
    ///
    /// Note: Your browser should be able to run plotly.js. Chrome, Safari, Edge, Firefox and
    /// etc. are supported.
    htmlout: PathBuf,
}

// Extra TODO: shift eigvals to E-fermi
impl Band {
    fn gen_kpath()-> Vec<f64> {
        todo!()
    }

    fn gen_rawband() -> Vector<f64> {
        todo!()
    }

    fn gen_pband() ->Vector<f64> {
        todo!()
    }

    fn get_outcarinfo() -> (f64,) {
        todo!()
    }

    fn filter_hse(procar: &mut Procar) -> bool {
        if !procar.kpoints.weights.iter().any(|x| x.abs() < 1E-6) {
            return false;
        }

        //procar.kpoints.kpointlist

        true
    }
}


impl OptProcess for Band {
    fn process(&self) -> Result<()> {
        let mut procar: Result<Procar> = Err(anyhow!(""));
        let mut outcar: Result<Outcar> = Err(anyhow!(""));

        rayon::scope(|s| {
            s.spawn(|_| {
                info!("Reading band data from {:?}", &self.procar);
                procar = Procar::from_file(&self.procar);
            });
            s.spawn(|_| {
                info!("Reading fermi level and lattice data from {:?}", &self.outcar);
                outcar = Outcar::from_file(&self.outcar);
            });
        });

        let mut procar = procar.context(format!("Parse PROCAR file {:?} failed.", self.procar))?;
        let outcar = outcar.context(format!("Parse OUTCAR file {:?} failed.", self.procar))?;

        let efermi = outcar.efermi;
        let cell = outcar.ion_iters.last()
            .context("This OUTCAR doesn't complete at least one ionic step.")?
            .cell;

        info!("Found Fermi level: {}, shifting eigenvalues ...", efermi);
        procar.pdos.eigvals -= efermi;

        if self.is_hse {
            if Self::filter_hse(&mut procar) {
                info!("Zero-contribution k-points filtered out for HSE system.")
            } else {
                warn!("Could not find zero-contribution k-points, processing the non-zero-contribution k-points.")
            }
        }
        
        Ok(())
    }
}
