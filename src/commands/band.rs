use std::{
    fs,
    path::PathBuf,
};

use indexmap::IndexMap;
use structopt::{
    StructOpt,
    clap::AppSettings,
};
use log::{
    info,
    debug,
};
use anyhow::bail;
use serde::{
    Serialize,
    Deserialize,
};

use crate::{
    Result,
    OptProcess,
    Procar,
    vasp_parsers::outcar::GetEFermi,
    types::Vector,
    commands::common::{
        write_array_to_txt,
        RawSelection,
    }
};


#[derive(Clone, Debug)]
struct Selection {
    label:      String,
    ispins:     Vec<usize>,
    ikpoints:   Vec<usize>,
    iatoms:     Vec<usize>,
    iorbits:    Vec<usize>,
    factor:     f64,
}


fn rawsel_to_sel(r: IndexMap<String, RawSelection>, 
                 nspin: usize,
                 is_ncl: bool,
                 nlm: &[String], 
                 nions: usize, 
                 nkpoints: usize) -> Result<Vec<Selection>> {

    let mut sel_vec = vec![];

    for (label, val) in r.into_iter() {
        let ispins      = RawSelection::parse_ispins(   val.spins.as_deref(),   nspin, is_ncl)?;
        let ikpoints    = RawSelection::parse_ikpoints( val.kpoints.as_deref(), nkpoints)?;
        let iatoms      = RawSelection::parse_iatoms(   val.atoms.as_deref(),   nions)?;
        let iorbits     = RawSelection::parse_iorbits(  val.orbits.as_deref(),  nlm)?;
        let factor      = val.factor.unwrap_or(1.0);

        if factor < 0.0 { bail!("The factor cannot be negative."); }

        let sel = Selection {
            label: label.to_string(),
            ispins,
            ikpoints,
            iatoms,
            iorbits,
            factor,
        };

        sel_vec.push(sel);
    }

    Ok(sel_vec)
}


#[derive(Clone, Serialize, Deserialize, Debug)]
struct Configuration {
    kpoint_labels: Option<Vec<String>>,

    #[serde(default = "Configuration::procar_default")]
    procar: PathBuf,

    #[serde(default = "Configuration::outcar_default")]
    outcar: PathBuf,

    #[serde(default = "Configuration::txtout_default")]
    txtout: PathBuf,

    #[serde(default = "Configuration::htmlout_default")]
    htmlout: PathBuf,

    pband: Option<IndexMap<String, RawSelection>>,
}

impl Configuration {
    pub fn procar_default() -> PathBuf { PathBuf::from("./PROCAR") }
    pub fn outcar_default() -> PathBuf { PathBuf::from("./OUTCAR") }
    pub fn txtout_default() -> PathBuf { PathBuf::from("./band_raw.txt") }
    pub fn htmlout_default() -> PathBuf { PathBuf::from("./band.html") }
}


#[derive(Debug, StructOpt, Clone)]
#[structopt(setting = AppSettings::ColoredHelp,
            setting = AppSettings::ColorAuto)]
pub struct Band {
    #[structopt(short, long)]
    /// Band structure plot configuration file path.
    ///
    /// If left empty, only bare band is calculated. The configuration template
    /// can be generated by `--gen-template` and then you can follow it.
    config: Option<PathBuf>,

    #[structopt(long)]
    /// Generate band structure plot configuration template.
    gen_template: bool,

    #[structopt(short, long)]
    /// Symbols for high symmetry points on the kpoint path.
    kpoint_labels: Option<Vec<String>>,

    #[structopt(long, default_value = "./PROCAR")]
    /// PROCAR path.
    ///
    /// The band level and projected band info are extracted from PROCAR.
    procar: PathBuf,

    #[structopt(long, default_value = "./OUTCAR")]
    /// OUTCAR path.
    ///
    /// The fermi level and lattice info are extracted from OUTCAR.
    outcar: PathBuf,

    #[structopt(long, default_value = "band.txt")]
    /// Save the raw data of band structure.
    ///
    /// Then you can replot it with more advanced tools.
    txtout: PathBuf,

    #[structopt(long, default_value = "band.html")]
    /// Save the band structure plot as HTML.
    ///
    /// Note: Your browser should be able to run plotly.js. Chrome, Safari, Edge, Firefox and
    /// etc. are supported.
    htmlout: PathBuf,
}


impl OptProcess for Band {
    fn process(&self) -> Result<()> {
        
        Ok(())
    }
}
