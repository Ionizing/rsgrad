use std::{
    path::PathBuf,
    fs,
};
use structopt::{
    StructOpt,
    clap::AppSettings,
};
use crate::{
    Poscar,
    traits::{
        Result,
        OptProcess,
        index_transform,
    },
};


#[derive(Debug, StructOpt)]
#[structopt(setting = AppSettings::ColoredHelp,
            setting = AppSettings::ColorAuto)]
/// Operation about POSCAR, including split it into two
pub struct Pos {
    #[structopt(short = "p", long, default_value = "./POSCAR")]
    /// Specify the input POSCAR file
    poscar: PathBuf,

    #[structopt(short = "i", long)]
    /// Selects the indices to operate.
    ///
    /// Step indices start from '1', if '0' is given, all the structures will be selected.
    /// Step indices can be negative, where negative index means counting reversely.
    /// E.g. "-i -2 -1 1 2 3" means selecting the last two and the first three atom.
    select_indices: Option<Vec<i32>>,

    #[structopt(short = "a", long, default_value = "POSCAR_A")]
    /// Specify the splitted POSCAR path with selected atoms
    a_name: PathBuf,

    #[structopt(short = "b", long, default_value = "POSCAR_B")]
    /// Specify the splitted POSCAR path with complement of `a_name`
    b_name: PathBuf,
}


fn poscar_split(poscar: &Poscar, inds: &Vec<usize>) -> (Poscar, Poscar) {
    // Assume the inds is neither empty nor full.
    
    let inds_a = inds.iter()
        .map(|x| *x as usize)
        .collect::<Vec<_>>();
    let inds_b = (0 .. poscar.pos_cart.len())
        .into_iter()
        .filter(|i| !inds.contains(i))
        .collect::<Vec<_>>();

    let (comment_a, comment_b) = ("Generated by rsgrad, POSCAR with selected atoms", "Generated by rsgrad, POSCAR complement");
    let scale = poscar.scale;
    let cell = poscar.cell.clone();

    let ion_types_total = &poscar.ion_types;
    let ions_per_type_total = &poscar.ions_per_type;

    let cumsum: Vec<usize> = {
        let mut ret = poscar.ions_per_type.iter().map(|x| *x as usize).collect::<Vec<_>>();
        let mut sum = ret[0];
        for i in 1..ret.len() {
            sum += ret[i];
            ret[i] = sum;
        }
        ret
    };

    let (ion_types_a, ions_per_type_a, ion_types_b, ions_per_type_b) = {
        let mut ions_per_type = vec![0usize; ions_per_type_total.len()];
        for _i in inds_a.iter() {
            let i = match cumsum.binary_search(&(_i + 1)) {
                Ok(n) => n,
                Err(n) => n,
            };
            ions_per_type[i] += 1;
        }
        let ion_types_a = ions_per_type.iter().zip(ion_types_total.iter())
            .filter(|(n, _)| n != &&0)
            .map(|(_, s)| s.clone())
            .collect::<Vec<_>>();
        let ions_per_type_a = ions_per_type.iter()
            .filter(|x| x > &&0)
            .map(|x| *x as i32)
            .collect::<Vec<i32>>();

        let ions_per_type_b = ions_per_type_total
            .iter().zip(ions_per_type.iter())
            .map(|(t, a)| *t - *a as i32)
            .filter(|x| x > &0)
            .collect::<Vec<i32>>();

        let ion_types_b = ions_per_type_b.iter().zip(ion_types_total.iter())
            .filter(|(n, _)| n != &&0)
            .map(|(_, s)| s.clone())
            .collect::<Vec<_>>();

        (ion_types_a, ions_per_type_a, ion_types_b, ions_per_type_b)
    };
        
    let pos_cart_a = inds_a.iter()
        .map(|i| poscar.pos_cart[*i])
        .collect::<Vec<_>>();

    let pos_frac_a = inds_a.iter()
        .map(|i| poscar.pos_frac[*i])
        .collect::<Vec<_>>();
    
    let pos_cart_b = inds_b.iter()
        .map(|i| poscar.pos_cart[*i])
        .collect::<Vec<_>>();

    let pos_frac_b = inds_b.iter()
        .map(|i| poscar.pos_frac[*i])
        .collect::<Vec<_>>();

    let (constraints_a, constraints_b) = if let Some(constraints) = poscar.constraints.as_ref() {
        (
            Some(inds_a.iter()
                    .map(|i| constraints[*i])
                    .collect::<Vec<_>>())
            ,
            Some(inds_b.iter()
                    .map(|i| constraints[*i])
                    .collect::<Vec<_>>())
        )
    } else {
        (None, None)
    };

    let poscar_a = Poscar {
        comment: comment_a.into(),
        scale: scale.clone(),
        cell: cell.clone(),
        ion_types: ion_types_a,
        ions_per_type: ions_per_type_a,
        pos_cart: pos_cart_a,
        pos_frac: pos_frac_a,
        constraints: constraints_a,
    };

    let poscar_b = Poscar {
        comment: comment_b.into(),
        scale: scale.clone(),
        cell: cell.clone(),
        ion_types: ion_types_b,
        ions_per_type: ions_per_type_b,
        pos_cart: pos_cart_b,
        pos_frac: pos_frac_b,
        constraints: constraints_b,
    };

    (poscar_a, poscar_b)
}


impl OptProcess for Pos {
    fn process(&self) -> Result<()> {
        let pos = Poscar::from_file(&self.poscar)?;

        if let Some(select_indices) = self.select_indices.as_ref() {
            let inds = index_transform(select_indices.clone(), pos.get_natoms() as usize)
                .into_iter()
                .map(|i| i - 1)
                .collect::<Vec<_>>();
            let (poscar_a, poscar_b) = poscar_split(&pos, &inds);
            poscar_a.to_formatter()
                .preserve_constraints(true)
                .fraction_coordinates(true)
                .add_symbol_tags(true)
                .to_file(&self.a_name)?;

            poscar_b.to_formatter()
                .preserve_constraints(true)
                .fraction_coordinates(true)
                .add_symbol_tags(true)
                .to_file(&self.b_name)?;
        }

        Ok(())
    }
}
